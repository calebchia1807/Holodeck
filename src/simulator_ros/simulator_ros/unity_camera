#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
import socket
import json
import numpy as np
import cv2
from sensor_msgs.msg import Image, PointCloud2, PointField
from cv_bridge import CvBridge

class CameraPublisher(Node):
    def __init__(self):
        super().__init__('unity_camera_publisher')
        self.rgb_pub = self.create_publisher(Image, '/camera/rgb', 10)
        self.depth_pub = self.create_publisher(PointCloud2, '/camera/depth', 10)
        self.bridge = CvBridge()
        
        self.timer = self.create_timer(0.1, self.publish_camera_data)  # 10 Hz
        
        self.get_logger().info("AI2-THOR Camera Publisher Initialized")

    def publish_camera_data(self):
        try:
            # Request image and depth from AI2-THOR
            command = {"action": "GetImages"}
            response = self.send_command_to_unity(command)

            if response:
                # Process RGB Image
                rgb_image = np.array(response["image"])
                ros_rgb = self.bridge.cv2_to_imgmsg(rgb_image, encoding="bgr8")
                self.rgb_pub.publish(ros_rgb)

                # Process Depth Data
                depth_map = np.array(response["depth"], dtype=np.float32)
                point_cloud_msg = self.convert_depth_to_pointcloud(depth_map)
                self.depth_pub.publish(point_cloud_msg)

        except Exception as e:
            self.get_logger().error(f"Error in publishing camera data: {e}")

    def send_command_to_unity(self, command):
        try:
            client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            client_socket.connect(('localhost', 8888))
            client_socket.send(json.dumps(command).encode())

            response = client_socket.recv(4096).decode()
            client_socket.close()
            
            return json.loads(response)
        except ConnectionRefusedError:
            self.get_logger().error("Failed to connect to Unity server!")
            return None

    def convert_depth_to_pointcloud(self, depth_map):
        points = []
        height, width = depth_map.shape

        for v in range(height):
            for u in range(width):
                z = depth_map[v, u]
                if z > 0:  # Ignore invalid depth points
                    x = (u - width / 2) * z * 0.001  # Scale factor
                    y = (v - height / 2) * z * 0.001
                    points.append([x, y, z])

        fields = [
            PointField(name="x", offset=0, datatype=PointField.FLOAT32, count=1),
            PointField(name="y", offset=4, datatype=PointField.FLOAT32, count=1),
            PointField(name="z", offset=8, datatype=PointField.FLOAT32, count=1),
        ]

        point_cloud_msg = PointCloud2()
        point_cloud_msg.header.frame_id = "camera_link"
        point_cloud_msg.height = 1
        point_cloud_msg.width = len(points)
        point_cloud_msg.fields = fields
        point_cloud_msg.is_bigendian = False
        point_cloud_msg.point_step = 12
        point_cloud_msg.row_step = point_cloud_msg.point_step * len(points)
        point_cloud_msg.is_dense = True
        point_cloud_msg.data = np.asarray(points, dtype=np.float32).tobytes()

        return point_cloud_msg

def main(args=None):
    rclpy.init(args=args)
    node = CameraPublisher()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()